# Content Update Workflow

**Date:** 2025-11-09  
**Purpose:** Ensure JSON ISR cache stays fresh when content changes

## The Problem

- Content is stored in MongoDB
- JSON files (`prompts.json`, `patterns.json`) are ISR cache
- Time-based staleness checks are stupid (waste Vercel builds)
- **Solution:** Regenerate JSON only when content actually changes

## The Solution: Webhook-Triggered Regeneration

### When Content Changes → Trigger Webhook

**Webhook Endpoint:** `POST /api/webhooks/content-updated`

**Authentication:** 
```bash
Authorization: Bearer <WEBHOOK_SECRET>
```

**Payload:**
```json
{
  "type": "prompts" | "patterns" | "learning" | "all"
}
```

---

## Usage Scenarios

### 1. Manual Content Update (Admin UI)

When you add/edit prompts via admin UI:

```typescript
// After successful MongoDB update
await fetch('/api/webhooks/content-updated', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${process.env.WEBHOOK_SECRET}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ type: 'prompts' }),
});
```

### 2. Bulk Import Script

When running content import scripts:

```bash
# After script completes
curl -X POST https://engify.ai/api/webhooks/content-updated \
  -H "Authorization: Bearer $WEBHOOK_SECRET" \
  -H "Content-Type: application/json" \
  -d '{"type":"all"}'
```

### 3. Automated Content Pipeline

If you have automated content generation:

```typescript
// After AI generates new prompts
await updateMongoDb(newPrompts);

// Trigger regeneration
await fetch(process.env.WEBHOOK_URL, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${process.env.WEBHOOK_SECRET}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ type: 'prompts' }),
});
```

---

## What the Webhook Does

1. **Verifies authentication** (WEBHOOK_SECRET)
2. **Regenerates JSON files** based on type:
   - `prompts` → `public/data/prompts.json`
   - `patterns` → `public/data/patterns.json`
   - `learning` → `public/data/learning.json`
   - `all` → All of the above
3. **Logs the operation** for debugging
4. **Returns success/failure** status

---

## Integration Points

### Admin API Endpoints

Add webhook call to these endpoints:

- ✅ `POST /api/prompts` - Create prompt
- ✅ `PUT /api/prompts/[id]` - Update prompt
- ✅ `DELETE /api/prompts/[id]` - Delete prompt
- ✅ `POST /api/patterns` - Create pattern
- ✅ `PUT /api/patterns/[id]` - Update pattern
- ✅ `DELETE /api/patterns/[id]` - Delete pattern

**Example Integration:**

```typescript
// In your prompt update endpoint
export async function PUT(request: NextRequest) {
  // ... update MongoDB ...
  
  // Trigger JSON regeneration
  try {
    await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/content-updated`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.WEBHOOK_SECRET}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ type: 'prompts' }),
    });
  } catch (error) {
    // Log but don't fail the request
    logger.warn('Failed to trigger JSON regeneration', { error });
  }
  
  return NextResponse.json({ success: true });
}
```

---

## Fallback Strategy

Even with webhook-triggered regeneration, we still have triple fallback:

1. **JSON (ISR cache)** - Fast, regenerated by webhook
2. **Immutable Backup** - NEVER fails, always deployed
3. **MongoDB** - Last resort (M0 tier unreliable)

**Why this works:**
- Webhook keeps JSON fresh when content changes
- No time-based staleness (no false positives)
- Backup protects against webhook failures
- MongoDB as last resort for edge cases

---

## Environment Variables

Add to `.env.local` and Vercel:

```bash
# Webhook authentication
WEBHOOK_SECRET=<same-as-CRON_SECRET-or-unique>

# For webhook calls from server
NEXT_PUBLIC_APP_URL=https://engify.ai
```

---

## Testing

### Local Testing

```bash
# 1. Start dev server
pnpm dev

# 2. Trigger webhook
curl -X POST http://localhost:3000/api/webhooks/content-updated \
  -H "Authorization: Bearer $WEBHOOK_SECRET" \
  -H "Content-Type: application/json" \
  -d '{"type":"prompts"}'

# 3. Check logs for success
# 4. Verify public/data/prompts.json was updated
```

### Production Testing

```bash
# Trigger from Vercel dashboard or CLI
curl -X POST https://engify.ai/api/webhooks/content-updated \
  -H "Authorization: Bearer $WEBHOOK_SECRET" \
  -H "Content-Type: application/json" \
  -d '{"type":"all"}'
```

---

## Monitoring

**Success Indicators:**
- ✅ Webhook returns 200 status
- ✅ Logs show "Prompts JSON regenerated"
- ✅ `prompts.json` timestamp updated
- ✅ Site shows new content immediately

**Failure Indicators:**
- ❌ Webhook returns 401 (auth failed)
- ❌ Webhook returns 500 (regeneration failed)
- ❌ Logs show errors
- ❌ Site still shows old content

**Recovery:**
- Webhook failures are non-critical
- Site falls back to backup files
- Manual regeneration: `VERCEL_ENV=production pnpm exec tsx scripts/content/generate-prompts-json.ts`

---

## Benefits Over Time-Based Staleness

| Time-Based | Webhook-Based |
|------------|---------------|
| ❌ False positives | ✅ Only regenerates when needed |
| ❌ Wastes Vercel builds | ✅ No unnecessary builds |
| ❌ Costs money | ✅ Saves money |
| ❌ Arbitrary 1-hour limit | ✅ Content-driven updates |
| ❌ Breaks on old deployments | ✅ Works with any age JSON |

---

## Future Enhancements

1. **Redis flag** - Set "needs_regeneration" flag instead of immediate webhook
2. **Batch updates** - Collect multiple updates, regenerate once
3. **Incremental updates** - Update only changed items in JSON
4. **CDN purge** - Purge Vercel edge cache after regeneration
5. **Slack notifications** - Alert when content updated

---

## Related Files

- `src/app/api/webhooks/content-updated/route.ts` - Webhook implementation
- `src/lib/prompts/generate-prompts-json.ts` - JSON generator
- `src/lib/patterns/generate-patterns-json.ts` - JSON generator
- `docs/DATA_RESILIENCE_STRATEGY.md` - Fallback strategy

---

**Rule:** Content staleness is determined by actual changes, not arbitrary time limits.
