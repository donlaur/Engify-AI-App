# Cursor AI Rules for Engify.ai

## Project Context
- Next.js 15.5.4 (App Router, stable not canary)
- TypeScript strict mode
- MongoDB + NextAuth for auth
- Tailwind CSS + shadcn/ui
- OpenAI + Google AI integration

## Code Quality Standards

### TypeScript
- ALWAYS use strict mode
- NO `any` types - use `unknown` and type guards
- Prefer interfaces over types for objects
- Use Zod for runtime validation
- Export types from schema files (single source of truth)

### React/Next.js
- Use 'use client' only when necessary (forms, hooks, interactivity)
- Server components by default
- Async server components for data fetching
- No useEffect for data fetching - use server components
- Prefer Server Actions over API routes for mutations

### File Organization
- One component per file
- Co-locate types with components
- Shared types in `/lib/schemas`
- Utils in `/lib/utils`
- NO duplicate code - DRY principle

### Naming Conventions
- Components: PascalCase (e.g., `PromptCard.tsx`)
- Files: kebab-case for utils (e.g., `format-date.ts`)
- Functions: camelCase (e.g., `getUserProfile`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `MAX_RETRIES`)
- Database collections: snake_case (e.g., `prompt_history`)

### Imports
- Group imports: React → Next → External → Internal → Types
- Use absolute imports with `@/` prefix
- NO relative imports beyond one level

### Error Handling
- ALWAYS handle errors explicitly
- Use try/catch for async operations
- Return error objects, don't throw in API routes
- Log errors with context (user ID, action, timestamp)

### Security
- NEVER commit secrets or API keys
- Use environment variables for all config
- Validate ALL user input with Zod
- Sanitize data before database operations
- Use parameterized queries (MongoDB prevents injection)

### Performance
- Use React.memo() for expensive components
- Implement pagination for large lists
- Lazy load heavy components
- Optimize images with Next.js Image component
- Use dynamic imports for code splitting

### Styling
- Tailwind utility classes only
- Use shadcn/ui components as base
- NO custom CSS files
- Responsive by default (mobile-first)
- Dark mode support via Tailwind classes

### Database
- MongoDB with Mongoose schemas
- Use transactions for multi-document operations
- Index frequently queried fields
- Validate data with Zod before DB operations
- Use aggregation pipeline for complex queries

### API Routes
- Use NextResponse for all responses
- Return consistent error format: `{ error: string }`
- Include status codes (200, 400, 401, 500)
- Validate request body with Zod
- Check authentication with `auth()` from NextAuth

### Testing (when implemented)
- Write tests for critical paths
- Test error cases, not just happy path
- Mock external APIs (OpenAI, Google AI)
- Use React Testing Library for components
- Integration tests for API routes

## AI-Specific Guidelines

### When Generating Code
1. Read existing code patterns first
2. Match the existing style exactly
3. Use existing utilities and helpers
4. Don't reinvent the wheel
5. Ask if unsure about architecture decisions

### When Refactoring
1. Make small, focused changes
2. Don't break existing functionality
3. Update tests if they exist
4. Keep commits atomic and descriptive
5. Explain trade-offs in comments

### When Adding Features
1. Check if similar feature exists
2. Reuse existing components
3. Follow established patterns
4. Consider mobile responsiveness
5. Add proper TypeScript types

## Commit Message Format
```
type(scope): description

- feat: new feature
- fix: bug fix
- refactor: code refactoring
- docs: documentation
- style: formatting
- test: adding tests
- chore: maintenance
```

## What NOT to Do
- ❌ NO `any` types
- ❌ NO `console.log` in production code
- ❌ NO inline styles
- ❌ NO duplicate code
- ❌ NO unhandled promises
- ❌ NO hardcoded values (use constants)
- ❌ NO mixing server/client components incorrectly
- ❌ NO committing commented-out code
- ❌ NO TODO comments without tickets
- ❌ NO mock data in production code (see ADR-009)
- ❌ NO fallback values like `|| 100` for stats (use 0 or omit)
- ❌ NO fake views/ratings (start at 0, show empty state)

## Day 7 Patterns & Best Practices

### Mock Data Removal (ADR-009)
- **Zero tolerance:** No mock data in production code
- **Start at 0:** Initialization values should be 0, not fake numbers
- **Empty states:** Show professional empty states instead of fake data
- **Single source of truth:** All stats come from `/api/stats` endpoint
- **Pre-commit checks:** Mock data patterns are automatically flagged

### Pattern-Based Bug Fixing (ADR-009)
- **Fix once, apply everywhere:** When fixing a bug, search for the same pattern
- **Systematic audit:** Don't fix one instance, fix all instances
- **Document patterns:** Add to PATTERN_AUDIT_DAY7.md
- **Prevent recurrence:** Add pre-commit checks or linting rules

### Frontend Component Architecture (ADR-011)
- **Server Components by default:** Only use Client Components when needed
- **Component size:** Target < 200 lines, extract logic to hooks
- **Error boundaries:** Wrap Client Components in ErrorBoundary
- **Loading states:** Use branded skeletons, not "Loading..." text
- **Optimistic UI:** Use optimistic updates for mutations with rollback
- **Data fetching:** Server Components for DB queries, API routes when needed

### Component Guidelines
- **Server Components:** Use for data fetching, static content, backend resources
- **Client Components:** Use for interactivity, hooks, browser APIs, event handlers
- **Separation:** Clear Server/Client boundary, extract interactive parts
- **Example Pattern:**
  ```typescript
  // Server Component (page.tsx)
  export default async function Page() {
    const data = await fetchData();
    return <ClientComponent data={data} />;
  }
  
  // Client Component (ClientComponent.tsx)
  'use client';
  export function ClientComponent({ data }: Props) {
    const [state, setState] = useState();
    // Interactive logic
  }
  ```

### Pre-commit Hook Standards
- **Enterprise compliance:** Run automatically on commit
- **Mock data checks:** Flags fallback values, fake metrics, TODO comments
- **API route requirements:** Rate limiting, tests, RBAC, audit logging
- **Component requirements:** Error boundaries, tests for new components
- **Schema requirements:** organizationId for multi-tenant compliance

### Related Documentation
- ADR-009: Mock Data Removal Strategy (`docs/development/ADR/009-mock-data-removal-strategy.md`)
- ADR-011: Frontend Component Architecture (`docs/development/ADR/011-frontend-component-architecture.md`)
- Pattern Audit: `docs/testing/PATTERN_AUDIT_DAY7.md`
- Mock Data Audit: `docs/testing/MOCK_DATA_AUDIT_DAY7.md`

## Progressive Enhancement Philosophy
1. Start with TypeScript files (fast iteration)
2. Move to database when patterns emerge
3. Add tests when APIs stabilize
4. Optimize when performance issues appear
5. Ship fast, iterate faster

## Questions to Ask Before Coding
1. Does this already exist in the codebase?
2. Can I reuse an existing component/utility?
3. Is this the simplest solution?
4. Will this scale?
5. Is this secure?

## MANDATORY: AI Guardrails (Pre-Change Checklist)

**CRITICAL:** Before making ANY changes, AI assistants MUST:

### 1. Search for Existing Tools (MANDATORY)
```bash
# Before creating ANY script/validation:
find scripts/ -name "*<keyword>*"
grep -r "validate\|check\|audit" scripts/ --include="*.ts" --include="*.js"

# If tool exists: USE IT, don't duplicate
# Example: Icon audit script existed but wasn't used → broke production
```

### 2. Check Pre-Commit Hooks (MANDATORY)
```bash
# Before adding validation:
cat .husky/pre-commit

# If similar check exists: EXTEND IT
# If missing: ADD IT to pre-commit
# Never bypass with --no-verify without documenting why
```

### 3. Run Guardrail Check (MANDATORY)
```bash
# Before making changes:
./scripts/ai/pre-change-check.sh all

# Or for specific type:
./scripts/ai/pre-change-check.sh validation <keyword>
```

### 4. Verify Tooling Works (MANDATORY)
```bash
# If using existing tool:
tsx scripts/path/to/existing-tool.ts

# If tool broken: FIX IT, don't work around
```

### 5. Document Decisions
- If bypassing hook: Explain why in commit message
- If creating duplicate: Explain why existing won't work
- If ignoring existing pattern: Explain why

**Reference:** `docs/development/AI_GUARDRAILS.md` for full guide

**Failure to follow these guardrails = preventable production breakage**

## Remember
- Velocity AND quality, not one or the other
- Ship fast, but ship production-ready code
- No ego - delete and start over if needed
- Code is read more than written
- Future you will thank present you for good docs
